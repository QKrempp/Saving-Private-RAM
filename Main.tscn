[gd_scene load_steps=24 format=3 uid="uid://rqfac7yewprr"]

[ext_resource type="PackedScene" uid="uid://bl4iswbwybro2" path="res://Player.tscn" id="1_glv2v"]
[ext_resource type="Script" uid="uid://cmsp16brd2o8w" path="res://main.gd" id="1_r0du0"]
[ext_resource type="Texture2D" uid="uid://dlugab0o1q0ht" path="res://Art/Envrionment/Mur1Angle.png" id="2_c6i3y"]
[ext_resource type="Script" uid="uid://5attjqatjtlm" path="res://grid_manager.gd" id="2_j4qnp"]
[ext_resource type="Script" uid="uid://cy237pyaj8i7b" path="res://RAM.gd" id="2_uu6xs"]
[ext_resource type="Texture2D" uid="uid://ndwly0t6aavc" path="res://Art/Envrionment/Mur1AngleOblique.png" id="3_c2ibq"]
[ext_resource type="Script" path="res://xpbar.gd" id="4_3dxm6"]
[ext_resource type="AudioStream" uid="uid://d0cxcsryo5c05" path="res://Sound Assets/Music/bg_ambience_music.mp3" id="4_fos0i"]
[ext_resource type="Texture2D" uid="uid://b1l57wpd4107s" path="res://Art/Envrionment/Mur1Droit.png" id="4_j4qnp"]
[ext_resource type="Texture2D" uid="uid://be7l8rb5xb7jf" path="res://Art/Envrionment/Mur1PetitAngle.png" id="5_fpfj3"]
[ext_resource type="Script" path="res://level.gd" id="5_lgr22"]
[ext_resource type="Texture2D" uid="uid://chjt2vjjorqmj" path="res://Art/Envrionment/Sol1.png" id="6_sc1dx"]
[ext_resource type="PackedScene" uid="uid://cofm2bjldku1x" path="res://LevelUpUi.tscn" id="8_trn2v"]

[sub_resource type="TileSetAtlasSource" id="TileSetAtlasSource_03owx"]
texture = ExtResource("6_sc1dx")
texture_region_size = Vector2i(140, 140)
0:0/0 = 0
0:0/0/z_index = -5

[sub_resource type="TileSet" id="TileSet_c2ibq"]
tile_size = Vector2i(140, 140)
sources/0 = SubResource("TileSetAtlasSource_03owx")

[sub_resource type="GDScript" id="GDScript_c2ibq"]
script/source = "extends TileMapLayer


"

[sub_resource type="TileSetAtlasSource" id="TileSetAtlasSource_c6i3y"]
texture = ExtResource("2_c6i3y")
texture_region_size = Vector2i(140, 140)
0:0/0 = 0

[sub_resource type="TileSetAtlasSource" id="TileSetAtlasSource_c2ibq"]
texture = ExtResource("3_c2ibq")
texture_region_size = Vector2i(140, 140)
0:0/0 = 0

[sub_resource type="TileSetAtlasSource" id="TileSetAtlasSource_j4qnp"]
texture = ExtResource("4_j4qnp")
texture_region_size = Vector2i(140, 140)
0:0/0 = 0

[sub_resource type="TileSetAtlasSource" id="TileSetAtlasSource_fpfj3"]
texture = ExtResource("5_fpfj3")
texture_region_size = Vector2i(140, 140)
0:0/0 = 0

[sub_resource type="TileSet" id="TileSet_bg4s2"]
tile_size = Vector2i(140, 140)
sources/0 = SubResource("TileSetAtlasSource_c6i3y")
sources/1 = SubResource("TileSetAtlasSource_c2ibq")
sources/2 = SubResource("TileSetAtlasSource_j4qnp")
sources/3 = SubResource("TileSetAtlasSource_fpfj3")

[sub_resource type="GDScript" id="GDScript_c6i3y"]
script/source = "class_name World extends TileMapLayer

#const SPAWNER: PackedScene = preload(\"res://EnemySpawner.tscn\")
#const TILE_SIZE := 140;
#
#@export var width: int = 30
#@export var height: int = 50
#@export var wall_probability: float = 0.55  # proba initiale de mur
#@export var smooth_steps: int = 5            # itérations d'automate cellulaire
#@export var connect_regions: bool = true     # relier toutes les zones vides
#@export var keep_largest_only: bool = false  # si true, supprime les petites zones au lieu de les relier
#
#var player_pos_grid = Vector2i.ZERO
#var player_pixel_pos = Vector2i.ZERO
#
#var grid: Array = []  # grid[y][x] = 0 (vide) ou 1 (mur)
#var rooms: Array = []
#
#func _ready() -> void:
	#generate()
	#render_map()
	#sort_regions_by_size()
	#var player_pos_array = _region_center(rooms[0])
	##player_pos_grid = random_pos()
	#player_pos_grid = Vector2i(player_pos_array[0], player_pos_array[1])
	#player_pixel_pos = Vector2i(player_pos_grid.x * TILE_SIZE, player_pos_grid.y * TILE_SIZE)
	##print_grid()
	#
	#
#func put_spawner_in_regions():
	#for region in rooms.slice(1):
		#var spawner = SPAWNER.instantiate()
		#var pos = _region_center(region)
		#spawner.global_position = Vector2(pos.x * TILE_SIZE, pos.y * TILE_SIZE)
		#get_tree().current_scene.add_child(spawner)
#
#func random_pos() -> Vector2:
	#var count := 0
	#while count < 1000:
		#var res = Vector2(randi_range(0, width), randi_range(0, height))
		#if grid[res.y][res.x] == 0:
			#return res
		#count+=1
	#return Vector2(0, 0)
#
#func render_map():
	#for y in range(0, height):
		#for x in range(width):
			#if grid[y][x] == 1:
				#set_cell(Vector2(x, y), 2, Vector2(0, 0))
			#else:
				#set_cell(Vector2(x, y), 4, Vector2(0, 0))
#
#func generate(p_width: int = -1, p_height: int = -1, p_wall_probability: float = -1.0, p_smooth_steps: int = -1) -> void:
	## Paramètres
	#if p_width > 0: width = p_width
	#if p_height > 0: height = p_height
	#if p_wall_probability >= 0.0: wall_probability = clampf(p_wall_probability, 0.0, 1.0)
	#if p_smooth_steps >= 0: smooth_steps = p_smooth_steps
#
	#grid = _random_fill(width, height, wall_probability)
#
	#for i in smooth_steps:
		#grid = _simulate_step(grid)
#
	#rooms = _get_regions_of(0)
	#_set_borders_as_walls(grid)
#
	#if connect_regions:
		#_connect_all_regions()
#
	#_set_borders_as_walls(grid)
#
#func _random_fill(w: int, h: int, p: float) -> Array:
	#var g := []
	#g.resize(h)
	#for y in h:
		#var row := PackedInt32Array()
		#row.resize(w)
		#for x in w:
			## Bords = murs
			#if x == 0 or y == 0 or x == w - 1 or y == h - 1:
				#row[x] = 1
			#else:
				#if randf() < p:
					#row[x] = 1
				#else:
					#row[x] = 0
		#g[y] = row
	#return g
#
#func _simulate_step(g: Array) -> Array:
	#var w = g[0].size()
	#var h = g.size()
	#var out = []
	#out.resize(h)
	#for y in h:
		#var row := PackedInt32Array()
		#row.resize(w)
		#for x in w:
			#var count := _count_wall_neighbors(g, x, y)
			## Règle classique : si beaucoup de murs autour => ce cell devient mur, sinon vide
			## Ajustez les seuils pour plus/moins de cavernes.
			#if count > 4:
				#row[x] = 1
			#elif count < 4:
				#row[x] = 0
			#else:
				#row[x] = g[y][x]
		#out[y] = row
	#return out
#
#func _count_wall_neighbors(g: Array, cx: int, cy: int) -> int:
	#var w = g[0].size()
	#var h = g.size()
	#var c = 0
	#for dy in range(-1, 2):
		#for dx in range(-1, 2):
			#if dx == 0 and dy == 0:
				#continue
			#var x := cx + dx
			#var y := cy + dy
			#if x < 0 or y < 0 or x >= w or y >= h:
				#c += 1 # hors carte = mur implicite
			#else:
				#c += g[y][x]
	#return c
#
#func _set_borders_as_walls(g: Array) -> void:
	#var w = g[0].size()
	#var h := g.size()
	#for x in w:
		#g[0][x] = 1
		#g[h - 1][x] = 1
	#for y in h:
		#g[y][0] = 1
		#g[y][w - 1] = 1
#
## --------- Connexité / Régions ---------
#
#func _get_regions_of(value: int) -> Array:
	## Renvoie une liste de régions, chaque région = Array de Vector2i (positions)
	#var w = grid[0].size()
	#var h := grid.size()
	#var visited := {}
	#var regions := []
	#for y in h:
		#for x in w:
			#if grid[y][x] == value and not visited.has(Vector2i(x, y)):
				#var region := _flood_fill(Vector2i(x, y), value, visited)
				#regions.append(region)
	#return regions
#
#func _flood_fill(start: Vector2i, value: int, visited: Dictionary) -> Array:
	#var q := [start]
	#var region := []
	#visited[start] = true
	#while not q.is_empty():
		#var p: Vector2i = q.pop_back()
		#region.append(p)
		#for dir in [Vector2i(1,0), Vector2i(-1,0), Vector2i(0,1), Vector2i(0,-1)]:
			#var n = p + dir
			#if _in_bounds(n) and grid[n.y][n.x] == value and not visited.has(n):
				#visited[n] = true
				#q.append(n)
	#return region
#
#func _in_bounds(p: Vector2i) -> bool:
	#return p.x >= 0 and p.y >= 0 and p.y < grid.size() and p.x < grid[0].size()
#
#func sort_regions_by_size():
	#if rooms.is_empty():
		#return []
	#rooms.sort_custom(func(a, b): return a.size() > b.size())
#
#func _connect_all_regions() -> void:
	#var regions := _get_regions_of(0)
	#if regions.size() <= 1:
		#return
	## On calcule un \"centre\" simple par région (médiane)
	#var centers := []
	#for region in regions:
		#centers.append(_region_center(region))
	## On relie séquentiellement les centres par des couloirs en L (Manhattan)
	#for i in range(1, centers.size()):
		#_carve_corridor(centers[i - 1], centers[i])
#
#func find_closest_start_point(p: Vector2) -> Vector2: # not working
	#var delta = 0
	#while delta < max(width, height):
		#for i in range(int(p.x - delta), int(p.x+delta)):
			#for j in range(int(p.y-delta), int(p.y+delta)):
				#if grid[j][i] == 0:
					#return Vector2(i, j)
		#delta+=1
	#return Vector2(0, 0)
#
#func _region_center(region: Array) -> Vector2i:
	## Centre ~ médian pour réduire l'influence des outliers
	#var xs := PackedInt32Array()
	#var ys := PackedInt32Array()
	#xs.resize(region.size())
	#ys.resize(region.size())
	#for i in region.size():
		#xs[i] = region[i].x
		#ys[i] = region[i].y
	#xs.sort()
	#ys.sort()
	#return Vector2i(xs[xs.size() / 2], ys[ys.size() / 2])
#
#func _carve_corridor(a: Vector2i, b: Vector2i) -> void:
	## Couloir en L : horizontal puis vertical (ou l'inverse au hasard)
	#if randf() < 0.5:
		#_carve_line_x(a.x, b.x, a.y)
		#_carve_line_y(a.y, b.y, b.x)
	#else:
		#_carve_line_y(a.y, b.y, a.x)
		#_carve_line_x(a.x, b.x, b.y)
#
#func _carve_line_x(x0: int, x1: int, y: int) -> void:
	#var step
	#if x1 > x0:
		#step = 1
	#else:
		#step = -1
	#for x in range(x0, x1 + step, step):
		#_dig(Vector2i(x, y))
#
#func _carve_line_y(y0: int, y1: int, x: int) -> void:
	#var step
	#if y1 > y0:
		#step = 1
	#else:
		#step = -1
	#for y in range(y0, y1 + step, step):
		#_dig(Vector2i(x, y))
#
#func _dig(p: Vector2i) -> void:
	#if _in_bounds(p):
		#grid[p.y][p.x] = 0
#
## --------- Utilitaires ---------
#
#func print_grid() -> void:
	## Affiche la carte avec '#' pour mur et '.' pour vide
	#var sb := []
	#for y in grid.size():
		#var line := \"\"
		#for x in grid[0].size():
			#if x == player_pos_grid.x and player_pos_grid.y == y:
				#line += \"O\"
			#elif grid[y][x] == 1:
				#line += \"#\"
			#else:
				#line += \".\"
		#sb.append(line)
	#print(\"\\n\".join(sb))
"

[sub_resource type="StyleBoxFlat" id="StyleBoxFlat_3dxm6"]
bg_color = Color(4.33177e-06, 0.667755, 0.803827, 1)

[node name="Room" type="Node2D"]
script = ExtResource("1_r0du0")

[node name="GridManager" type="Node" parent="."]
script = ExtResource("2_j4qnp")

[node name="Floor" type="TileMapLayer" parent="GridManager"]
tile_set = SubResource("TileSet_c2ibq")
script = SubResource("GDScript_c2ibq")

[node name="World" type="TileMapLayer" parent="GridManager"]
tile_set = SubResource("TileSet_bg4s2")
script = SubResource("GDScript_c6i3y")

[node name="MainCharacter" parent="." instance=ExtResource("1_glv2v")]
position = Vector2(161, 89)

[node name="Camera2D" type="Camera2D" parent="MainCharacter"]

[node name="Overlay" type="CanvasLayer" parent="."]

[node name="xpbar" type="ProgressBar" parent="Overlay"]
offset_left = 5.0
offset_top = 33.0
offset_right = 196.0
offset_bottom = 42.0
theme_override_styles/fill = SubResource("StyleBoxFlat_3dxm6")
show_percentage = false
script = ExtResource("4_3dxm6")

[node name="level" type="Label" parent="Overlay"]
offset_left = 204.0
offset_top = 25.0
offset_right = 245.0
offset_bottom = 48.0
theme_override_colors/font_color = Color(0, 0.666667, 0.803922, 1)
text = "LVL 0"
script = ExtResource("5_lgr22")

[node name="RAM" type="Label" parent="Overlay"]
offset_right = 40.0
offset_bottom = 23.0
text = "Coucou"
script = ExtResource("2_uu6xs")
total_ram = 1024

[node name="MusiqueDeFond" type="AudioStreamPlayer" parent="."]
stream = ExtResource("4_fos0i")
autoplay = true

[node name="LevelUpUi" parent="." instance=ExtResource("8_trn2v")]
